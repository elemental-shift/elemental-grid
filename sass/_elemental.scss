$columns: 12; //total number of columns to use
$gutter: 3%; // gutter width can be any unit
$column_width: 5.33333333333333%; // column width can be any unit

// calculated total width
$total_width: $columns * ($gutter + $column_width);

// Sub-pixel fix for IE http://tylertate.com/blog/2012/01/05/subpixel-rounding.html
// min width in pixels, do not append px to the number.
$min_width: 480;
$ie_correction: (.5 / $min_width) * 100 * 1%;


// calculate width of a column based on it's span.
@function width( $span ) {
    @return ( $span * $column_width ) + ( $gutter * ( $span - 1 ) );
}

// micro clearfix hack 
// http://nicolasgallagher.com/micro-clearfix-hack/
@mixin clearfix {
    &:before,
    &:after {
        content: "";
        display: table;
    }
    &:after {
        clear: both;
    }
    *zoom:1;
}

// set box sizing for all elements
// http://paulirish.com/2012/box-sizing-border-box-ftw/
* {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box; }

// Sets up a container for individual columns
// row width and margin calculation based on Tyler Tate's Semantic.gs
@mixin row() {
    display: block;
    width: $total_width*(($gutter + $total_width)/$total_width);
    margin-right: $total_width*((($gutter*.5)/$total_width)*-1);
    margin-left: $total_width*((($gutter*.5)/$total_width)*-1);
    *width: $total_width*(($gutter + $total_width)/$total_width) - $ie_correction;
    *margin-right:($total_width*((($gutter*.5)/$total_width)*-1)) - $ie_correction;
    *margin-left:($total_width*((($gutter*.5)/$total_width)*-1)) - $ie_correction;
    @include clearfix;
}

// Sets single column and determins the offset distance and direction.
//
// $span: default 1; Determins the width of the column;
// $type: default none; has three available options
//                push: pushes column to the right by the specified amount of columns
//                pull: pulls a column to the left by a specified amount of columns
//                center: centers a column of the desired size in the container
//
// $offset: default 0; determines the amount by which push and pull offset the column
// $last: default false; if true the column will be floated to the right;

@mixin column( $span: 1, $type: none, $offset: 0, $last:false ) {
    @if $last == true {
        float: right;
    } @else {
        float: left;
    }
    width: width( $span );
    *width: width($span) - $ie_correction;
    @if $type == none {
        margin-right: $gutter / 2;
        margin-left: $gutter / 2;
        *margin-right: (( $gutter / 2 ) - $ie_correction );
        *margin-left: (( $gutter / 2 ) - $ie_correction );
    } @else if $type == push {
        margin-right: ( $gutter / 2 );
        margin-left: ( width( $offset ) + ( $gutter * 1.5 ) );
        *margin-right: ( ( $gutter / 2 ) - $ie_correction );
        *margin-left: ( width( $offset ) + ( $gutter * 1.5 ) - $ie_correction );
    } @else if $type == pull {
        margin-right: ( width( $offset ) + ( $gutter * 1.5 ) );
        margin-left: ( $gutter / 2 );
        *margin-right: ( width( $offset ) + ( $gutter * 1.5 ) - $ie_correction );
        *margin-left: ( ( $gutter / 2 ) - $ie_correction );
    } @else if $type == center {
        display: block;
        width: width( $span );
        margin-left: auto;
        margin-right: auto;
        float: none !important;
    }
}

// Used to order columns right-to-left. Sets single column and determins the offset distance and direction.
//
// $span: default 1; Determins the width of the column;
// $type: default none; has three available options
//                push: pushes column to the left by the specified amount of columns
//                pull: pulls a column to the right by a specified amount of columns
//                center: centers a column of the desired size in the container
//
// $offset: default 0; determines the amount by which push and pull offset the column
// $last: default false; if true the column will be floated to the left

@mixin column_right( $span: 1, $type: none, $offset: 0, $last:false ) {
    @if $last == true {
        float: left;
    } @else {
        float: right;
    }
    width: width( $span );
    *width: width($span) - $ie_correction;
    @if $type == none {
        margin-right: $gutter / 2;
        margin-left: $gutter / 2;
        *margin-right: (( $gutter / 2 ) - $ie_correction );
        *margin-left: (( $gutter / 2 ) - $ie_correction );
    } @else if $type == push {
        margin-right: ( width( $offset ) + ( $gutter * 1.5 ) );
        margin-left: ( $gutter / 2 ) ;
        *margin-right: ( width( $offset ) + ( $gutter * 1.5 ) - $ie_correction );
        *margin-left: ( $gutter / 2 );
    } @else if $type == pull {
        margin-right: ( $gutter / 2 );
        margin-left: ( width( $offset ) + ( $gutter * 1.5 ) );
        *margin-right: ( ( $gutter / 2 ) - $ie_correction );
        *margin-left: ( width( $offset ) + ( $gutter * 1.5 ) - $ie_correction );
    } @else if $type == center {
        display: block;
        width: width( $span );
        margin-right: auto;
        margin-left: auto;
        float: none !important;
    }
}


// Creates a grid from an elements children. By default it is designed to work
// on a unordered list, but it can work with any element type chosed by the
// $element variable.
//
// $width: default 4; defines with amount of elemeents per row
// $margin: default $gutter variable; sets margin between each item
// $element: default li; defines the type element to target
@mixin grid( $width:4, $margin:$gutter, $element:li ) {
    @include clearfix;
    overflow: hidden;
    margin-left: -#{$margin};
    clear: both;
    & > #{$element} {
        float: left;
        display: block;
        width: ( $total_width / $width ) - $margin;
        margin: 0 0 $margin $margin;
        *width: ( $total_width / $width ) - $margin - $ie_correction;
        *margin: 0 0 ( $margin - $ie_correction ) ( $margin - $ie_correction );
        &:nth-child( #{$width}n + #{$width}) {
            float: right;
        }
        &:nth-child( #{$width}n + #{$width+1}) {
            clear: both;
        }
    }
}